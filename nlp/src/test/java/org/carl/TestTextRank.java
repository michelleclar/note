package org.carl;

import org.carl.tools.TextRank;
import org.junit.jupiter.api.Test;

public class TestTextRank {
    @Test
    public void testGenSummar() {
        String context =
                """
                    概述

                    进程管理

                    进程与线程

                    要点:

                    理解进程线程基本概念

                    了解进程线程之间的区别

                    总结:

                    进程:进程是资源分配的基本单位。

                    线程:线程是独立调度的基本单位。

                    进程有自己独立的内存空间和系统资源,所以它的上下文切换开销大于线程,并发性也不如线程。

                    线程有公共的堆栈和局部变量,线程是进程的子任务，它可以共享进程的资源，因此线程间的切换开销更小，并发性更高。

                    ThreadLocal实现的线程间的资源隔离是每个线程各自维护了一个ThreadLocalMap

                    一般情况下线程于线程之间的切换不会导致进程切换,只有从一个进程中的线程切换到另一个进程中的线程时，会引起进程切换。

                    进程之间通信需要借助IPC,线程间可以通过直接读写同一进程中的数据进行通信

                    进程状态的切换

                    要点:

                    了解进程有哪些状态

                    了解进程状态是如何产生的

                    总结:

                    进程有三个状态:

                    - 就绪状态（ready）：等待被调度
                      - 当进程没有被阻塞并没有在运行时,会进入就绪状态等待调度
                      - 而运行状态的进程，在分配给它的 CPU 时间片用完之后就会转为就绪状态，等待下一次调度。
                    - 运行状态（running）
                      - 就绪状态的进程通过调度算法从而获得 CPU 时间，转为运行状态
                    - 阻塞状态（waiting）：等待资源
                      - 阻塞状态是缺少需要的资源从而由运行状态转换而来

                    就绪运行之间是相互转化的它们的转化是可以主动转化的,运行到阻塞是被动的

                    进程调度算法

                    要点:

                    了解各系统有哪些调度算法

                    了解这些算法的优缺点

                    总结:

                    批处理系统:先来先服务（FCFS）,短作业优先（SJF）,最短剩余时间优先（SRTN）

                    交互式系统:时间片轮转,优先级调度,多级反馈队列

                    实时系统:实时系统要求一个请求在一个确定时间内得到响应。分为硬实时和软实时，前者必须满足绝对的截止时间，后者可以容忍一定的超时。

                    先来先服务 :有利于长作业，但不利于短作业

                    因为短作业必须一直等待前面的长作业执行完毕才能执行，而长作业又需要执行很长时间，造成了短作业等待时间过长。

                    短作业优先 :长作业有可能会饿死，处于一直等待短作业执行完毕的状态

                    因为如果一直有短作业到来，那么长作业永远得不到调度。

                    最短剩余时间优先 :短作业优先plus版,解决长作业永远得不到调度。

                     时间片轮转:一个比较成熟的算法,缺点在于时间片的选取太小，会导致进程切换得太频繁，在进程切换上就会花过多时间。过长，那么实时性就不能得到保证。

                    当一个时间片完成时，才会进行程序的上下文切换，分配给下一个程序。因此，如果时间片过长，那么一个程序就会在较长的时间内运行，其他程序就需要等待，这就不利于系统的效率。

                    优先级调度:为每个进程分配一个优先级，按优先级进行调度。

                    为了防止低优先级的进程永远等不到调度，可以随着时间的推移增加等待进程的优先级。

                    多级反馈队列:时间片轮转调度算法和优先级调度算法的结合

                    进程同步

                    要点:

                    了解进程是如何进行同步的

                    理解生产者消费者模型

                    总结:

                    进程间的同步可以通过以下几种方法实现：

                    1. 互斥锁：在进程间共享数据的情况下，控制多个进程对数据的访问。
                    2. 信号量：控制多个进程同时执行的数量。
                    3. 消息传递：在进程间通过发送和接收消息来进行通信和同步。
                    4. 共享内存：在进程间共享内存，以实现进程间的通信和同步。

                    生产者于消费者:

                        #define N 100
                        typedef int semaphore;
                        semaphore mutex = 1;
                        semaphore empty = N;
                        semaphore full = 0;
                       \s
                        void producer() {
                            while(TRUE) {
                                int item = produce_item();
                                down(&empty);
                                down(&mutex);
                                insert_item(item);
                                up(&mutex);
                                up(&full);
                            }
                        }
                       \s
                        void consumer() {
                            while(TRUE) {
                                down(&full);
                                down(&mutex);
                                int item = remove_item();
                                consume_item(item);
                                up(&mutex);
                                up(&empty);
                            }
                        }

                    进程通信

                    用于进程同步的一些手段

                    管道:

                    它具有以下限制：

                    - 只支持半双工通信（单向交替传输）；
                    - 只能在父子进程或者兄弟进程中使用。

                    FIFO:也称为命名管道，去除了管道只能在父子进程中使用的限制。

                    FIFO 常用于客户-服务器应用程序中，FIFO 用作汇聚点，在客户进程和服务器进程之间传递数据。

                    消息队列:

                    消息队列可以独立于读写进程存在，从而避免了 FIFO 中同步管道的打开和关闭时可能产生的困难；
                    避免了 FIFO 的同步阻塞问题，不需要进程自己提供同步方法；
                    读进程可以根据消息类型有选择地接收消息，而不像 FIFO 那样只能默认地接收。

                    消息队列属于非阻塞I/O

                    信号量:是一个计数器，用于为多个进程提供对共享数据对象的访问。

                    共享存储:允许多个进程共享一个给定的存储区。因为数据不需要在进程之间复制，所以这是最快的一种 IPC。

                    需要使用信号量用来同步对共享存储的访问。

                    类似线程之间的通信

                    套接字:用于不同机器间的进程通信。

                    ip:端口号

                                            """;
        String str = TextRank.generateSummaryByTextRank(context);
        System.out.println(str);
    }
}
